classdef SP_Cl
    %% SP_CL Suspension Parameters Class
    %   contains data on suspension design
    
    %% copyright field
    properties
        COPYRIGHT (1,1) string;
    end
    
    %% general design parameters (gravity, wheelbase)
    properties
        G (1,1) general_SY_parameters_Cl;
    end
    
    %% end structures (design parameters, MR arrays)
    properties
        R (1,1) R_end_Cl;
        F (1,1) F_end_Cl;
    end

    %% corner structures (3D points, rotation matricies)
    properties
        FL (1,1) FL_corner_Cl;
        FR (1,1) FR_corner_Cl;
        RL (1,1) RL_corner_Cl;
        RR (1,1) RR_corner_Cl;
    end
    
    %% simulation control structures
    properties
        SC (1,1) sim_control_container_Cl;
    end
    
    %% get functions for corner and simulation control structures
    methods
        function out = get.FL(obj)
            obj.FL.F_ref = obj.F;
            obj.FL.R_ref = obj.R;
            obj.FL.G_ref = obj.G;
            out = obj.FL;
        end
        function out = get.FR(obj)
            obj.FR.F_ref = obj.F;
            obj.FR.R_ref = obj.R;
            obj.FR.G_ref = obj.G;
            out = obj.FR;
        end
        function out = get.RL(obj)
            obj.RL.F_ref = obj.F;
            obj.RL.R_ref = obj.R;
            obj.RL.G_ref = obj.G;
            out = obj.RL;
        end
        function out = get.RR(obj)
            obj.RR.F_ref = obj.F;
            obj.RR.R_ref = obj.R;
            obj.RR.G_ref = obj.G;
            out = obj.RR;
        end
        function out = get.SC(obj)
            obj.SC.F_ref = obj.F;
            obj.SC.R_ref = obj.R;
            obj.SC.G_ref = obj.G;
            out = obj.SC;
        end
    end

    %% auto-calculation functions
    methods
        function obj = F_AC_geometry(obj)
            %% general comments
            % this function automatically calculates all link and control
            % arm lengths and motion ratio arrays for the front suspension.
            % 
            % note that everything here is calculated on the left side of
            % the car because that is the +Y side in the ISO coordinate
            % system that this model uses. all Y dimensions are fliped
            % when constructing the right side for the multibody model.
            % 
            % all variables in this function are organized into 3D frames.
            % 
            
            %% calculate WP rotation matrices
            % note that on the left side of the car, all three of these
            % angles are are actually defined as positive in the LH
            % direction (+camber = -rotation around X, +caster = -rotation
            % around Y, +toe = -rotation around Z). fortunately, the RM_gen
            % function requires the negative of the angle you want to
            % rotate your frame by, so we can just feed these angles in 
            % raw. (see RM_gen function for more details).
            
            WP_fr.RM_toe = SP_Cl.RM_gen(obj.F.SY.static_toe, 3);
            WP_fr.RM_camber = SP_Cl.RM_gen(obj.F.SY.static_camber, 1);
            WP_fr.RM_caster = SP_Cl.RM_gen(obj.F.SY.static_caster, 2);
            
            % these are applied in the order the have to be to avoid
            % fucking each other up. toe is defined relative to the to the
            % world, camber is defined in a plane normal to the ground that
            % contains the wheel axis, and caster is defined (at least in
            % this model) looking dead-on at the face of the wheel.
            WP_fr.RM = WP_fr.RM_caster * WP_fr.RM_camber * WP_fr.RM_toe;
            
            %% place WP relative to CH
            % note that if you ever want to design static toe (I don't know
            % why you would want to, but this model does give you that
            % option), and you have static camber (which you should), the
            % contact patch and the wheel origin will then be at slightly
            % different X positions. currently, the contact patch X is
            % defined at a system level, because it was easier to write
            % robust code to deal with that. if you want to use the wheel
            % origin X, you'll have to write that yourself.
            
            % because the upright, and therefore the WP frame, is rotated
            % in caster, but you still want the contact patch to be the
            % lowest point on the centerline of the tire in the world
            % frame.
            WP_fr.contact_patch = ...
                obj.F.WP.radius ...
                * [-sind(obj.F.SY.static_caster); ...
                   0; ...
                   -cosd(obj.F.SY.static_caster)];
            
            % define the contact patch in CH frame at rest. all the data is
            % already there, just put it in a convenient format.
            CH_fr.WP_contact_patch = ...
                [obj.F.SY.WP_contact_patch_X; ...
                 obj.F.SY.static_track / 2; ...
                 -obj.F.SY.ride_height];
            
            % find the WP origin in CH frame.
            CH_fr.WP_origin = ...
                CH_fr.WP_contact_patch ...
                - WP_fr.RM' ...
                * WP_fr.contact_patch;
            
            %% find WP pickups in CH frame and define rack end conveniently
            
            % transform WP points to CH frame
            CH_fr.WP_UA_pickup = ...
                CH_fr.WP_origin + WP_fr.RM' * obj.FL.WP.UA_pickup;
            CH_fr.WP_LA_pickup = ...
                CH_fr.WP_origin + WP_fr.RM' * obj.FL.WP.LA_pickup;
            CH_fr.WP_TL_pickup = ...
                CH_fr.WP_origin + WP_fr.RM' * obj.FL.WP.TL_pickup;
            
            % rack end
            CH_fr.RK_end = obj.FL.CH.RK_mount + obj.FL.RK.end_point;
            
            %% find lengths of control arms and toe link
            % control arm lengths are done using YZ-plane projections. they
            % are not valid for anti-dive/squat geometries. you can't
            % actually make those anyway because the front and rear chassis
            % pickups are defined to have the same Y and Z dimensions, but
            % just noting here that if you try to change that, you need to
            % rewrite this.
            
            obj.F.UA.length = ...
                norm(...
                    CH_fr.WP_UA_pickup(2:3) ...
                    - obj.FL.CH.UA_R_pickup(2:3));
            obj.F.LA.length = ...
                norm(...
                    CH_fr.WP_LA_pickup(2:3) ...
                    - obj.FL.CH.LA_R_pickup(2:3));
            obj.F.TL.length = ...
                norm(...
                    CH_fr.WP_TL_pickup ...
                    - CH_fr.RK_end);
            
            %% find control arm base lengths and apex X positions
            % basically the same notes as the last section. all lines
            % between front and rear pickups are assumed to be parallel to
            % the X-axis.
            
            obj.F.UA.base_length = ...
                obj.F.CH.UA_F_pickup_X - obj.F.CH.UA_R_pickup_X;
            obj.F.LA.base_length = ...
                obj.F.CH.LA_F_pickup_X - obj.F.CH.LA_R_pickup_X;
            obj.F.UA.apex_delta_X = ...
                CH_fr.WP_UA_pickup(1) - obj.F.CH.UA_R_pickup_X;
            obj.F.LA.apex_delta_X = ...
                CH_fr.WP_LA_pickup(1) - obj.F.CH.LA_R_pickup_X;
            
            %% find lengths of individual members of the control arms
            % just a bunch of norms of vector differences. standard method
            % for finding distance between 2 3D points.
            
            obj.F.UA.F_member_length = ...
                norm(...
                    [obj.F.UA.length; ...
                     obj.F.UA.base_length - obj.F.UA.apex_delta_X]);
            obj.F.UA.R_member_length = ...
                norm(...
                    [obj.F.UA.length; ...
                     obj.F.UA.apex_delta_X]);
            obj.F.LA.F_member_length = ...
                norm(...
                    [obj.F.LA.length; ...
                     obj.F.LA.base_length - obj.F.LA.apex_delta_X]);
            obj.F.LA.R_member_length = ...
                norm(...
                    [obj.F.LA.length; ...
                     obj.F.LA.apex_delta_X]);
            
            %% find lower arm PR pickup at rest
            % needed to define the rocker arm frame
            
            % the base point is defined as the point on the line between
            % the CH pickups with the same X coordinate as the apex. again,
            % won't work for anti-dive/squat.
            CH_fr.LA_base = ...
                obj.FL.CH.LA_R_pickup + [obj.F.LA.apex_delta_X; 0; 0];
            
            % find vector from base to apex.
            CH_fr.LA_delta_apex_base = ...
                CH_fr.WP_LA_pickup - CH_fr.LA_base;
            
            % find the angle the LA sit at at rest.
            LA_fr.angle = ...
                atan2d(...
                    CH_fr.LA_delta_apex_base(3), ...
                    CH_fr.LA_delta_apex_base(2));
            
            % define rotation matrix to transform from CH frame to LA
            % frame. remember the negative.
            LA_fr.RM = SP_Cl.RM_gen(-LA_fr.angle, 1);
            
            % actually do what the section title says.
            CH_fr.LA_PR_pickup = ...
                CH_fr.WP_LA_pickup + LA_fr.RM' * obj.FL.LA.PR_pickup;
            
            %% calculate RA frame rotation matrices
            % this is an alternate method of creating a rotation matrix to
            % define a coordinate frame. in this method, we find 3
            % orthogonal vectors to use as the X, Y, and Z of the new frame
            % and the assemple them into the rotation matrix. see the
            % general notes for the entire class for the directions we want
            % these vectors to point.
            
            % need for later.
            CH_fr.delta_LA_PR_pickup_RA_pickup = ...
                CH_fr.LA_PR_pickup - obj.FL.CH.RA_pickup;
            
            % X base points from CH RA pick towards CH SH pickup
            RA_fr.RM_bases.b1 = ...
                normalize(...
                    obj.FL.CH.SH_pickup ...
                    - obj.FL.CH.RA_pickup, 'norm');
            
            % Y base is in RA plane defined by CH RA pickup, CH SH pickup,
            % and LA PR pickup at rest. it is normal to the X base, and in
            % the front it points toward the side of the plane that
            % contains the LA PR pickup.
            RA_fr.RM_bases.b2 = ...
                normalize(...
                    CH_fr.delta_LA_PR_pickup_RA_pickup ...
                    - dot( ...
                        CH_fr.delta_LA_PR_pickup_RA_pickup, ...
                        RA_fr.RM_bases.b1) ...
                    * RA_fr.RM_bases.b1, ...
                    'norm');
            
            % Z base is defined by wanting an orthogonal, right-handed
            % coordinate system.
            RA_fr.RM_bases.b3 = ...
                cross(RA_fr.RM_bases.b1, RA_fr.RM_bases.b2);
            
            % assemble the matrix.
            obj.FL.RA.rotation_matrix = ...
                ([RA_fr.RM_bases.b1'; ...
                  RA_fr.RM_bases.b2'; ...
                  RA_fr.RM_bases.b3']);
            
            % the left rocker arm frame will obviously be flipped relative
            % to the right side. first, invert the Y component of each base
            % vector, as standard for converting from left to right.
            % however, in this case, that produces a left hand coordinate
            % system. to fix that, we flip the direction of the Z base,
            % since it's the one we give the least shits about.
            obj.FR.RA.rotation_matrix = ...
                obj.FL.RA.rotation_matrix .* ...
                [ 1, -1,  1; ...
                  1, -1,  1; ...
                 -1,  1, -1];
            
            %% find PR length
            % this section finds the postion of the rocker arm pushrod
            % pickup when the shock is at the specified rest length. then
            % the pushrod length is a simple subtraction with the lower
            % pickup.
            
            % because of the way the RA frame is defined, the chassis shock
            % pickup is just in the X direction from the origin (rocker arm
            % pickup)
            RA_fr.CH_SH_pickup = ...
                [norm(obj.FL.CH.RA_pickup - obj.FL.CH.SH_pickup); 0];
            
            % link up the shock at rest length and the shock pickup of the
            % RA. shock rest length stored in metric, so we need to
            % convert.
            RA_fr.SH_pickup = ...
                SP_Cl.circ_int( ...
                    [0; 0], ...
                    obj.F.RA.SH_radius, ...
                    RA_fr.CH_SH_pickup, ...
                    obj.F.SH.rest_length / .0254, ... % <- convert
                    -1);
            
            % angle is defined as the angle of the shock arm of the rocker
            % with the X axis.
            RA_fr.angle = atan2d(RA_fr.SH_pickup(2), RA_fr.SH_pickup(1));
            
            % find PR pickup using combined angle, radius, trig.
            RA_fr.PR_pickup = ...
                obj.F.RA.PR_radius * ...
                [cosd(RA_fr.angle + obj.F.RA.angle); ...
                 sind(RA_fr.angle + obj.F.RA.angle); ...
                 0];
            
            % convert to CH frame.
            CH_fr.RA_PR_pickup = ...
                obj.FL.RA.rotation_matrix' ...
                * RA_fr.PR_pickup ...
                + obj.FL.CH.RA_pickup;
            
            % actually do what the section title says.
            obj.F.PR.length = ...
                norm(CH_fr.RA_PR_pickup - CH_fr.LA_PR_pickup);
            
            %% motion ratio arrays
            % see class general notes and the comment on the correction 
            % factor for an explanation of why these are kind of trash. 
            % 
            % this whole section needs work if you want to run
            % anti-dive/squat.
            
            % travel stored in metric, needs conversion
            SY.jounce_array = ...
                linspace( ...
                    -obj.F.SY.travel / 0.0254, ...
                    obj.F.SY.travel / 0.0254, ...
                    obj.F.SY.MR_n_points);
            
            % this is some straight up bullshit based on the assumption
            % that the wheel travelling in an arc around the center of the
            % car. it's terrible, but it's better than assuming the apex
            % just moves the same amount as the wheel, and it keeps the
            % error between these motion ratios and the actual motion
            % ratios from the multibody model less than ~5%.
            SY.apex_motion_correction = ...
                (obj.F.SY.static_track / 2 + obj.F.WP.LA_pickup_Y) ...
                / (obj.F.SY.static_track / 2);
            
            % find roughly how much the apex moves in Z as the wheel moves
            CH_fr.LA_apex_Z_array = ...
                SY.apex_motion_correction * SY.jounce_array ...
                + CH_fr.WP_LA_pickup(3);
            
            % angle derived from Z
            LA_fr.angle_array = ...
                -asind( ...
                    (CH_fr.LA_apex_Z_array - obj.F.CH.LA_pickups_Z) ...
                    / obj.F.LA.length);
            
            % needed for next thing
            LA_fr.delta_PR_pickup_base = ...
                obj.FL.LA.PR_pickup + [0; obj.F.LA.length; 0];
            
            % this is essentially multiplying the vector from the base of
            % the control arm to to the PR pickup by bunch of different
            % 2D rotation matrices, but it's done this way because MATLAB
            % doesn't have a good syntax for that.
            CH_fr.LA_PR_pickup_array = ...
                [zeros(1, obj.F.SY.MR_n_points); ...
                 LA_fr.delta_PR_pickup_base(2) * cosd(LA_fr.angle_array) + ...
                 LA_fr.delta_PR_pickup_base(3) * sind(LA_fr.angle_array); ...
                 LA_fr.delta_PR_pickup_base(2) * -sind(LA_fr.angle_array) + ...
                 LA_fr.delta_PR_pickup_base(3) * cosd(LA_fr.angle_array)] ...
                + CH_fr.LA_base;
            
            % convert to RA frame
            RA_fr.LA_PR_pickup_array = ...
                obj.FL.RA.rotation_matrix * ...
                (CH_fr.LA_PR_pickup_array - obj.FL.CH.RA_pickup);
            
            % calculate the length of the PR projected into the RA frame XY
            % plane. the next calulation involves projecting into that
            % plane, so we need this.
            RA_fr.PR_in_plane_length_array = ...
                sqrt( ...
                    obj.F.PR.length^2 - ...
                    RA_fr.LA_PR_pickup_array(3,:).^2);
            
            % find the intersection of the circles defined by RA PR pickup
            % radius around the CH RA pickup (AKA the origin) and the PR
            % projected length and projected LA PR pickup. this is
            % mathmatically equivalent to finding the intersection of the
            % RA PR pickup circle  and the 3D sphere defined by the RA end
            % of the PR.
            RA_fr.PR_pickup_array = ...
                SP_Cl.circ_int( ...
                    [0;0], ...
                    obj.F.RA.PR_radius, ...
                    RA_fr.LA_PR_pickup_array(1:2,:), ...
                    RA_fr.PR_in_plane_length_array, ...
                    1);
            
            % if you have designed something that will result in the
            % linkage binding, the MR array will be full of NANs.
            if(max(imag(RA_fr.PR_pickup_array)) > 0)
                RA_fr.PR_pickup_array = ...
                    NaN * ones(2, obj.F.SY.MR_n_points);
            end
            
            % PR pickup position fully defines position of RA because it
            % only has 1 DOF. find angles to conveniently define that
            % position.
            RA_fr.angle_array = ...
                atan2d( ...
                    RA_fr.PR_pickup_array(2,:), ...
                    RA_fr.PR_pickup_array(1,:)) ...
                - obj.F.RA.angle;
            
            % find RA SH pickup at various jounces.
            RA_fr.SH_pickup_array = ...
                obj.F.RA.SH_radius * ...
                [cosd(RA_fr.angle_array); ...
                 sind(RA_fr.angle_array)];
            
            % find RA SH pickup at various jounces with respect to the CH
            % SH pickup.
            RA_fr.SH_2D_point_delta_array = ...
                RA_fr.SH_pickup_array - RA_fr.CH_SH_pickup;
            
            % normalize 2D difference vector between the ends of the shock
            % to find its length.
            RA_fr.SH_length_array = ...
                sqrt( ...
                    RA_fr.SH_2D_point_delta_array(1,:).^2 ...
                    + RA_fr.SH_2D_point_delta_array(2,:).^2);
            
            % find difference SH length and rest length. (because that's 
            % what we actually want to store.)
            SY.SH_delta_array = ...
                RA_fr.SH_length_array ...
                - obj.F.SH.rest_length / .0254;
            
            % take derivative of jounce and SH delta arrays to find MR.
            SY.MR_array = ...
                - gradient( ...
                    SY.SH_delta_array, ...
                    SY.jounce_array);
            
            % store results. note that all of these arrays are horizontal
            % because that works better for these computations, but
            % generally, we want to store arrays as vertical, so we flip
            % them. also, metric.
            obj.F.SY.jounce_array = SY.jounce_array' * 0.0254;
            obj.F.SY.SH_delta_array = SY.SH_delta_array' * 0.0254;
            obj.F.SY.MR_array = SY.MR_array';
            
        end
        function obj = F_AC_dynamics(obj, varargin)
            %% check for right number of inputs
            if ~(length(varargin) == 1 || length(varargin) == 3)
                error("Wrong number of mode arguments (either 1 or 3)");
            end
            
            %% find nominal motion ratio
            SY.ride_height_MR = ...
                obj.F.SY.MR_array(round(length(obj.F.SY.MR_array) / 2));
            
            %% spring/damper calculations
            switch varargin{1}
            case 'design'
                %% for design studies to spec shocks and springs
                % spring and damper rates are calculated from arbitrary
                % spring rate and damping ratio at the wheels.
                
                if length(varargin) ~= 3
                    error("Need 2 sub-mode arguments for design");
                end
                
                switch varargin{2}
                case 'ride'
                    switch varargin{3}
                    case 'rate'
                        obj.F.SY.omega_n = ...
                            sqrt(...
                                2 * obj.F.SY.wheel_spring_rate ...
                                / obj.F.CH.I.m) ...
                            / (2*pi);
                    case 'frequency'
                        obj.F.SY.wheel_spring_rate = ...
                            (2 * pi * obj.F.SY.omega_n)^2 ...
                            * obj.F.CH.I.m / 2;
                    otherwise
                        % complain
                        error("Error: Invalid Sub-Mode (either 'rate' or 'frequency')");
                    end
                    
                    % calculate wheel damping rate
                    obj.F.SY.wheel_damping_rate = ...
                        obj.F.SY.damping_ratio ...
                        * 2 * sqrt( ...
                            obj.F.SY.wheel_spring_rate * obj.F.CH.I.m / 2);
                    
                    % calculate roll mode parameters
                    obj.F.SY.roll_rate = ...
                        2 * obj.F.SY.wheel_spring_rate ...
                        * (obj.F.SY.static_track / 2 * 0.0254)^2 ...
                        * pi / 180;
                    obj.F.SY.roll_damping_rate = ...
                        2 * obj.F.SY.wheel_damping_rate ...
                        * (obj.F.SY.static_track / 2 * 0.0254)^2 ...
                        * pi / 180;
                    obj.F.SY.roll_damping_ratio = ...
                        (obj.F.SY.roll_damping_rate * 180 / pi) ...
                        / (2 * sqrt( ...
                            (obj.F.SY.roll_rate * 180 / pi) ...
                            * obj.F.CH.I.Ixx));
                    obj.F.SY.roll_omega_n = ...
                        sqrt(...
                            obj.F.SY.roll_rate * (180 / pi) ...
                            / obj.F.CH.I.Ixx) ...
                        / (2*pi);
                case 'roll'
                    switch varargin{3}
                    case 'rate'
                        obj.F.SY.roll_omega_n = ...
                            sqrt(...
                                obj.F.SY.roll_rate * (180 / pi) ...
                                / obj.F.CH.I.Ixx) ...
                            / (2*pi);
                    case 'frequency'
                        obj.F.SY.roll_rate = ...
                            (2 * pi * obj.F.SY.roll_omega_n)^2 ...
                            * obj.F.CH.I.Ixx ...
                            * (pi / 180);
                    otherwise
                        % complain
                        error("Error: Invalid Sub-Mode (either 'rate' or 'frequency')");
                    end
                    
                    % calculate roll damping rate
                    obj.F.SY.roll_damping_rate = ...
                        obj.F.SY.roll_damping_ratio ...
                        * 2 * sqrt( ...
                            (obj.F.SY.roll_rate * 180 / pi) ...
                            * obj.F.CH.I.Ixx) ...
                        * pi / 180;
                    
                    % calculate ride mode parameters
                    obj.F.SY.wheel_spring_rate = ...
                        (obj.F.SY.roll_rate * 180 / pi / 2)...
                        / (obj.F.SY.static_track / 2 * 0.0254)^2;
                    obj.F.SY.wheel_damping_rate = ...
                        (obj.F.SY.roll_damping_rate * 180 / pi / 2)...
                        / (obj.F.SY.static_track / 2 * 0.0254)^2;
                    obj.F.SY.damping_ratio = ...
                        obj.F.SY.wheel_damping_rate ...
                        / (2 * sqrt( ...
                            obj.F.SY.wheel_spring_rate ...
                            * obj.F.CH.I.m / 2));
                    obj.F.SY.omega_n = ...
                        sqrt(...
                            2 * obj.F.SY.wheel_spring_rate ...
                            / obj.F.CH.I.m) ...
                        / (2*pi);
                otherwise
                    % complain
                    error("Error: Invalid Sub-Mode (either 'ride' or 'roll')");
                end
                
                % calculate actual spring and damper rates
                obj.F.SH.spring_rate = ...
                    obj.F.SY.wheel_spring_rate / SY.ride_height_MR^2;
                obj.F.SH.damping_rate = ...
                    obj.F.SY.wheel_damping_rate / SY.ride_height_MR^2;
                
            case 'real' 
                %% for simulating car with purchased components
                % spring and damper rates are set to the actual values
                % of the springs and dampers that could/will be used on
                % the car. wheel and roll spring and damping rates are
                % calculated for the designer's convenience.
                
                if length(varargin) ~= 1
                    error("Real mode doesn''t need more arguments");
                end
                
                % calculate rates at the wheels
                obj.F.SY.wheel_spring_rate = ...
                    obj.F.SH.spring_rate * SY.ride_height_MR^2;
                obj.F.SY.wheel_damping_rate = ...
                    obj.F.SH.damping_rate * SY.ride_height_MR^2;
                
                % calculate rates in roll
                obj.F.SY.roll_rate = ...
                    2 * obj.F.SY.wheel_spring_rate ...
                    * (obj.F.SY.static_track / 2 * 0.0254)^2 ...
                    * pi / 180;
                obj.F.SY.roll_damping_rate = ...
                    2 * obj.F.SY.wheel_damping_rate ...
                    * (obj.F.SY.static_track / 2 * 0.0254)^2 ...
                    * pi / 180;
                
                % calculate damping ratios
                obj.F.SY.damping_ratio = ...
                    obj.F.SY.wheel_damping_rate ...
                    / (2 * sqrt( ...
                        obj.F.SY.wheel_spring_rate ...
                        * obj.F.CH.I.m / 2));
                obj.F.SY.roll_damping_ratio = ...
                    (obj.F.SY.roll_damping_rate * 180 / pi) ...
                    / (2 * sqrt( ...
                        (obj.F.SY.roll_rate * 180 / pi) ...
                        * obj.F.CH.I.Ixx));
                
                % calculate natural frequencies
                obj.F.SY.omega_n = ...
                    sqrt(...
                        2 * obj.F.SY.wheel_spring_rate ...
                        / obj.F.CH.I.m) ...
                    / (2*pi);
                obj.F.SY.roll_omega_n = ...
                    sqrt(...
                        obj.F.SY.roll_rate * (180 / pi) ...
                        / obj.F.CH.I.Ixx) ...
                    / (2*pi);
                
            otherwise 
                %% complain
                % if this section of code is activated, you fucked up.
                error("Error: Invalid Mode (either \'design\ or \'real\')");
                
            end
            
            %% find preload
            SY.static_spring_load = ...
                0.5 * obj.F.CH.I.m * obj.G.gravity / SY.ride_height_MR;
            SY.static_spring_compression = ...
                SY.static_spring_load / obj.F.SH.spring_rate;
            SY.lower_travel = ...
                obj.F.SH.max_length - obj.F.SH.rest_length;
            obj.F.SH.preload = ...
                SY.static_spring_compression - SY.lower_travel;
            
        end
        function obj = R_AC_geometry(obj)
            %% general comments
            % this function automatically calculates all link and control
            % arm lengths and motion ratio arrays for the front suspension.
            % 
            % note that everything here is calculated on the left side of
            % the car because that is the +Y side in the ISO coordinate
            % system that this model uses. all Y dimensions are fliped
            % when constructing the right side for the multibody model.
            % 
            % all variables in this function are organized into 3D frames.
            % 
            
            %% calculate WP rotation matrices
            % note that on the left side of the car, all three of these
            % angles are are actually defined as positive in the LH
            % direction (+camber = -rotation around X, +caster = -rotation
            % around Y, +toe = -rotation around Z). fortunately, the RM_gen
            % function requires the negative of the angle you want to
            % rotate your frame by, so we can just feed these angles in 
            % raw. (see RM_gen function for more details).
            
            WP_fr.RM_toe = SP_Cl.RM_gen(obj.R.SY.static_toe, 3);
            WP_fr.RM_camber = SP_Cl.RM_gen(obj.R.SY.static_camber, 1);
            WP_fr.RM_caster = SP_Cl.RM_gen(obj.R.SY.static_caster, 2);
            
            % these are applied in the order the have to be to avoid
            % fucking each other up. toe is defined relative to the to the
            % world, camber is defined in a plane normal to the ground that
            % contains the wheel axis, and caster is defined (at least in
            % this model) looking dead-on at the face of the wheel.
            WP_fr.RM = WP_fr.RM_caster * WP_fr.RM_camber * WP_fr.RM_toe;
            
            %% place WP relative to CH
            % note that if you ever want to design static toe (I don't know
            % why you would want to, but this model does give you that
            % option), and you have static camber (which you should), the
            % contact patch and the wheel origin will then be at slightly
            % different X positions. currently, the contact patch X is
            % defined at a system level, because it was easier to write
            % robust code to deal with that. if you want to use the wheel
            % origin X, you'll have to write that yourself.
            
            % because the upright, and therefore the WP frame, is rotated
            % in caster, but you still want the contact patch to be the
            % lowest point on the centerline of the tire in the world
            % frame.
            WP_fr.contact_patch = ...
                obj.R.WP.radius ...
                * [-sind(obj.R.SY.static_caster); ...
                   0; ...
                   -cosd(obj.R.SY.static_caster)];
            
            % define the contact patch in CH frame at rest. all the data is
            % already there, just put it in a convenient format.
            CH_fr.WP_contact_patch = ...
                [obj.R.SY.WP_contact_patch_X; ...
                 obj.R.SY.static_track / 2; ...
                 -obj.R.SY.ride_height];
            
            % find the WP origin in CH frame.
            CH_fr.WP_origin = ...
                CH_fr.WP_contact_patch ...
                - WP_fr.RM' ...
                * WP_fr.contact_patch;
            
            %% find WP pickups in CH frame
            
            % transform WP points to CH frame
            CH_fr.WP_UA_pickup = ...
                CH_fr.WP_origin + WP_fr.RM' * obj.RL.WP.UA_pickup;
            CH_fr.WP_LA_pickup = ...
                CH_fr.WP_origin + WP_fr.RM' * obj.RL.WP.LA_pickup;
            CH_fr.WP_TL_pickup = ...
                CH_fr.WP_origin + WP_fr.RM' * obj.RL.WP.TL_pickup;
            
            %% find lengths of control arms and toe link
            % control arm lengths are done using YZ-plane projections. they
            % are not valid for anti-dive/squat geometries. you can't
            % actually make those anyway because the front and rear chassis
            % pickups are defined to have the same Y and Z dimensions, but
            % just noting here that if you try to change that, you need to
            % rewrite this.
            
            obj.R.UA.length = ...
                norm(...
                    CH_fr.WP_UA_pickup(2:3) ...
                    - obj.RL.CH.UA_R_pickup(2:3));
            obj.R.LA.length = ...
                norm(...
                    CH_fr.WP_LA_pickup(2:3) ...
                    - obj.RL.CH.LA_R_pickup(2:3));
            obj.R.TL.length = ...
                norm(...
                    CH_fr.WP_TL_pickup ...
                    - obj.RL.CH.TL_pickup);
            
            %% find control arm base lengths and apex X positions
            % basically the same notes as the last section. all lines
            % between front and rear pickups are assumed to be parallel to
            % the X-axis.
            
            obj.R.UA.base_length = ...
                obj.R.CH.UA_F_pickup_X - obj.R.CH.UA_R_pickup_X;
            obj.R.LA.base_length = ...
                obj.R.CH.LA_F_pickup_X - obj.R.CH.LA_R_pickup_X;
            obj.R.UA.apex_delta_X = ...
                CH_fr.WP_UA_pickup(1) - obj.R.CH.UA_R_pickup_X;
            obj.R.LA.apex_delta_X = ...
                CH_fr.WP_LA_pickup(1) - obj.R.CH.LA_R_pickup_X;
            
            %% find lengths of individual members of the control arms
            % just a bunch of norms of vector differences. standard method
            % for finding distance between 2 3D points.
            
            obj.R.UA.F_member_length = ...
                norm(...
                    [obj.R.UA.length; ...
                     obj.R.UA.base_length - obj.R.UA.apex_delta_X]);
            obj.R.UA.R_member_length = ...
                norm(...
                    [obj.R.UA.length; ...
                     obj.R.UA.apex_delta_X]);
            obj.R.LA.F_member_length = ...
                norm(...
                    [obj.R.LA.length; ...
                     obj.R.LA.base_length - obj.R.LA.apex_delta_X]);
            obj.R.LA.R_member_length = ...
                norm(...
                    [obj.R.LA.length; ...
                     obj.R.LA.apex_delta_X]);
            
            %% find upper arm PR pickup at rest
            % needed to define the rocker arm frame
            
            % the base point is defined as the point on the line between
            % the CH pickups with the same X coordinate as the apex. again,
            % won't work for anti-dive/squat.
            CH_fr.UA_base = ...
                obj.RL.CH.UA_R_pickup + [obj.R.UA.apex_delta_X; 0; 0];
            
            % find vector from base to apex.
            CH_fr.UA_delta_apex_base = ...
                CH_fr.WP_UA_pickup - CH_fr.UA_base;
            
            % find the angle the UA sit at at rest.
            UA_fr.angle = ...
                atan2d(...
                    CH_fr.UA_delta_apex_base(3), ...
                    CH_fr.UA_delta_apex_base(2));
            
            % define rotation matrix to transform from CH frame to UA
            % frame. remember the negative.
            UA_fr.RM = SP_Cl.RM_gen(-UA_fr.angle, 1);
            
            % actually do what the section title says.
            CH_fr.UA_PR_pickup = ...
                CH_fr.WP_UA_pickup + UA_fr.RM' * obj.RL.UA.PR_pickup;
            
            %% calculate RA frame rotation matrices
            % this is an alternate method of creating a rotation matrix to
            % define a coordinate frame. in this method, we find 3
            % orthogonal vectors to use as the X, Y, and Z of the new frame
            % and the assemple them into the rotation matrix. see the
            % general notes for the entire class for the directions we want
            % these vectors to point.
            
            % need for later.
            CH_fr.delta_UA_PR_pickup_RA_pickup = ...
                CH_fr.UA_PR_pickup - obj.RL.CH.RA_pickup;
            
            % X base points from CH RA pick towards CH SH pickup
            RA_fr.RM_bases.b1 = ...
                normalize(...
                    obj.RL.CH.SH_pickup ...
                    - obj.RL.CH.RA_pickup, 'norm');
            
            % Y base is in RA plane defined by CH RA pickup, CH SH pickup,
            % and UA PR pickup at rest. it is normal to the X base, and in
            % the front it points toward the side of the plane that
            % contains the UA PR pickup.
            RA_fr.RM_bases.b2 = ...
                -1 * normalize(...
                    CH_fr.delta_UA_PR_pickup_RA_pickup ...
                    - dot( ...
                        CH_fr.delta_UA_PR_pickup_RA_pickup, ...
                        RA_fr.RM_bases.b1) ...
                    * RA_fr.RM_bases.b1, ...
                    'norm');
            
            % Z base is defined by wanting an orthogonal, right-handed
            % coordinate system.
            RA_fr.RM_bases.b3 = ...
                cross(RA_fr.RM_bases.b1, RA_fr.RM_bases.b2);
            
            % assemble the matrix.
            obj.RL.RA.rotation_matrix = ...
                ([RA_fr.RM_bases.b1'; ...
                  RA_fr.RM_bases.b2'; ...
                  RA_fr.RM_bases.b3']);
            
            % the left rocker arm frame will obviously be flipped relative
            % to the right side. first, invert the Y component of each base
            % vector, as standard for converting from left to right.
            % however, in this case, that produces a left hand coordinate
            % system. to fix that, we flip the direction of the Z base,
            % since it's the one we give the least shits about.
            obj.RR.RA.rotation_matrix = ...
                obj.RL.RA.rotation_matrix .* ...
                [ 1, -1,  1; ...
                  1, -1,  1; ...
                 -1,  1, -1];
            
            %% find PR length
            % this section finds the postion of the rocker arm pushrod
            % pickup when the shock is at the specified rest length. then
            % the pushrod length is a simple subtraction with the lower
            % pickup.
            
            % because of the way the RA frame is defined, the chassis shock
            % pickup is just in the X direction from the origin (rocker arm
            % pickup)
            RA_fr.CH_SH_pickup = ...
                [norm(obj.RL.CH.RA_pickup - obj.RL.CH.SH_pickup); 0];
            
            % link up the shock at rest length and the shock pickup of the
            % RA. shock rest length stored in metric, so we need to
            % convert.
            RA_fr.SH_pickup = ...
                SP_Cl.circ_int( ...
                    [0; 0], ...
                    obj.R.RA.SH_radius, ...
                    RA_fr.CH_SH_pickup, ...
                    obj.R.SH.rest_length / .0254, ... % <- convert
                    -1);
            
            % angle is defined as the angle of the shock arm of the rocker
            % with the X axis.
            RA_fr.angle = atan2d(RA_fr.SH_pickup(2), RA_fr.SH_pickup(1));
            
            % find PR pickup using combined angle, radius, trig.
            RA_fr.PR_pickup = ...
                obj.R.RA.PR_radius * ...
                [cosd(RA_fr.angle + obj.R.RA.angle); ...
                 sind(RA_fr.angle + obj.R.RA.angle); ...
                 0];
            
            % convert to CH frame.
            CH_fr.RA_PR_pickup = ...
                obj.RL.RA.rotation_matrix' ...
                * RA_fr.PR_pickup ...
                + obj.RL.CH.RA_pickup;
            
            % actually do what the section title says.
            obj.R.PR.length = ...
                norm(CH_fr.RA_PR_pickup - CH_fr.UA_PR_pickup);
            
            %% motion ratio arrays
            % see class general notes and the comment on the correction 
            % factor for an explanation of why these are kind of trash. 
            % 
            % this whole section needs work if you want to run
            % anti-dive/squat.
            
            % travel stored in metric, needs conversion
            SY.jounce_array = ...
                linspace( ...
                    -obj.R.SY.travel / 0.0254, ...
                    obj.R.SY.travel / 0.0254, ...
                    obj.R.SY.MR_n_points);
            
            % this is some straight up bullshit based on the assumption
            % that the wheel travelling in an arc around the center of the
            % car. it's terrible, but it's better than assuming the apex
            % just moves the same amount as the wheel, and it keeps the
            % error between these motion ratios and the actual motion
            % ratios from the multibody model less than ~5%.
            SY.apex_motion_correction = ...
                (obj.R.SY.static_track / 2 + obj.R.WP.UA_pickup_Y) ...
                / (obj.R.SY.static_track / 2);
            
            % find roughly how much the apex moves in Z as the wheel moves
            CH_fr.UA_apex_Z_array = ...
                SY.apex_motion_correction * SY.jounce_array ...
                + CH_fr.WP_UA_pickup(3);
            
            % angle derived from Z
            UA_fr.angle_array = ...
                -asind( ...
                    (CH_fr.UA_apex_Z_array - obj.R.CH.UA_pickups_Z) ...
                    / obj.R.UA.length);
            
            % needed for next thing
            UA_fr.delta_PR_pickup_base = ...
                obj.RL.UA.PR_pickup + [0; obj.R.UA.length; 0];
            
            % this is essentially multiplying the vector from the base of
            % the control arm to to the PR pickup by bunch of different
            % 2D rotation matrices, but it's done this way because MATLAB
            % doesn't have a good syntax for that.
            CH_fr.UA_PR_pickup_array = ...
                [zeros(1, obj.R.SY.MR_n_points); ...
                 UA_fr.delta_PR_pickup_base(2) * cosd(UA_fr.angle_array) + ...
                 UA_fr.delta_PR_pickup_base(3) * sind(UA_fr.angle_array); ...
                 UA_fr.delta_PR_pickup_base(2) * -sind(UA_fr.angle_array) + ...
                 UA_fr.delta_PR_pickup_base(3) * cosd(UA_fr.angle_array)] ...
                + CH_fr.UA_base;
            
            % convert to RA frame
            RA_fr.UA_PR_pickup_array = ...
                obj.RL.RA.rotation_matrix * ...
                (CH_fr.UA_PR_pickup_array - obj.RL.CH.RA_pickup);
            
            % calculate the length of the PR projected into the RA frame XY
            % plane. the next calulation involves projecting into that
            % plane, so we need this.
            RA_fr.PR_in_plane_length_array = ...
                sqrt( ...
                    obj.R.PR.length^2 - ...
                    RA_fr.UA_PR_pickup_array(3,:).^2);
            
            % find the intersection of the circles defined by RA PR pickup
            % radius around the CH RA pickup (AKA the origin) and the PR
            % projected length and projected UA PR pickup. this is
            % mathmatically equivalent to finding the intersection of the
            % RA PR pickup circle  and the 3D sphere defined by the RA end
            % of the PR.
            RA_fr.PR_pickup_array = ...
                SP_Cl.circ_int( ...
                    [0;0], ...
                    obj.R.RA.PR_radius, ...
                    RA_fr.UA_PR_pickup_array(1:2,:), ...
                    RA_fr.PR_in_plane_length_array, ...
                    1);
            
            % if you have designed something that will result in the
            % linkage binding, the MR array will be full of NANs.
            if(max(imag(RA_fr.PR_pickup_array)) > 0)
                RA_fr.PR_pickup_array = ...
                    NaN * ones(2, obj.R.SY.MR_n_points);
            end
            
            % PR pickup position fully defines position of RA because it
            % only has 1 DOF. find angles to conveniently define that
            % position.
            RA_fr.angle_array = ...
                atan2d( ...
                    RA_fr.PR_pickup_array(2,:), ...
                    RA_fr.PR_pickup_array(1,:)) ...
                - obj.R.RA.angle;
            
            % find RA SH pickup at various jounces.
            RA_fr.SH_pickup_array = ...
                obj.R.RA.SH_radius * ...
                [cosd(RA_fr.angle_array); ...
                 sind(RA_fr.angle_array)];
            
            % find RA SH pickup at various jounces with respect to the CH
            % SH pickup.
            RA_fr.SH_2D_point_delta_array = ...
                RA_fr.SH_pickup_array - RA_fr.CH_SH_pickup;
            
            % normalize 2D difference vector between the ends of the shock
            % to find its length.
            RA_fr.SH_length_array = ...
                sqrt( ...
                    RA_fr.SH_2D_point_delta_array(1,:).^2 ...
                    + RA_fr.SH_2D_point_delta_array(2,:).^2);
            
            % find difference SH length and rest length. (because that's 
            % what we actually want to store.)
            SY.SH_delta_array = ...
                RA_fr.SH_length_array ...
                - obj.R.SH.rest_length / .0254;
            
            % take derivative of jounce and SH delta arrays to find MR.
            SY.MR_array = ...
                - gradient( ...
                    SY.SH_delta_array, ...
                    SY.jounce_array);
            
            % store results. note that all of these arrays are horizontal
            % because that works better for these computations, but
            % generally, we want to store arrays as vertical, so we flip
            % them. also, metric.
            obj.R.SY.jounce_array = SY.jounce_array' * 0.0254;
            obj.R.SY.SH_delta_array = SY.SH_delta_array' * 0.0254;
            obj.R.SY.MR_array = SY.MR_array';
            
        end
        function obj = R_AC_dynamics(obj, varargin)
            %% check for right number of inputs
            if ~(length(varargin) == 1 || length(varargin) == 3)
                error("Wrong number of mode arguments (either 1 or 3)");
            end
            
            %% find nominal motion ratio
            SY.ride_height_MR = ...
                obj.R.SY.MR_array(round(length(obj.R.SY.MR_array) / 2));
            
            %% spring/damper calculations
            switch varargin{1}
            case 'design'
                %% for design studies to spec shocks and springs
                % spring and damper rates are calculated from arbitrary
                % spring rate and damping ratio at the wheels.
                
                if length(varargin) ~= 3
                    error("Need 2 sub-mode arguments for design");
                end
                
                switch varargin{2}
                case 'ride'
                    switch varargin{3}
                    case 'rate'
                        obj.R.SY.omega_n = ...
                            sqrt(...
                                2 * obj.R.SY.wheel_spring_rate ...
                                / obj.R.CH.I.m) ...
                            / (2*pi);
                    case 'frequency'
                        obj.R.SY.wheel_spring_rate = ...
                            (2 * pi * obj.R.SY.omega_n)^2 ...
                            * obj.R.CH.I.m / 2;
                    otherwise
                        % complain
                        error("Error: Invalid Sub-Mode (either 'rate' or 'frequency')");
                    end
                    
                    % calculate wheel damping rate
                    obj.R.SY.wheel_damping_rate = ...
                        obj.R.SY.damping_ratio ...
                        * 2 * sqrt( ...
                            obj.R.SY.wheel_spring_rate * obj.R.CH.I.m / 2);
                    
                    % calculate roll mode parameters
                    obj.R.SY.roll_rate = ...
                        2 * obj.R.SY.wheel_spring_rate ...
                        * (obj.R.SY.static_track / 2 * 0.0254)^2 ...
                        * pi / 180;
                    obj.R.SY.roll_damping_rate = ...
                        2 * obj.R.SY.wheel_damping_rate ...
                        * (obj.R.SY.static_track / 2 * 0.0254)^2 ...
                        * pi / 180;
                    obj.R.SY.roll_damping_ratio = ...
                        (obj.R.SY.roll_damping_rate * 180 / pi) ...
                        / (2 * sqrt( ...
                            (obj.R.SY.roll_rate * 180 / pi) ...
                            * obj.R.CH.I.Ixx));
                    obj.R.SY.roll_omega_n = ...
                        sqrt(...
                            obj.R.SY.roll_rate * (180 / pi) ...
                            / obj.R.CH.I.Ixx) ...
                        / (2*pi);
                case 'roll'
                    switch varargin{3}
                    case 'rate'
                        obj.R.SY.roll_omega_n = ...
                            sqrt(...
                                obj.R.SY.roll_rate * (180 / pi) ...
                                / obj.R.CH.I.Ixx) ...
                            / (2*pi);
                    case 'frequency'
                        obj.R.SY.roll_rate = ...
                            (2 * pi * obj.R.SY.roll_omega_n)^2 ...
                            * obj.R.CH.I.Ixx ...
                            * (pi / 180);
                    otherwise
                        % complain
                        error("Error: Invalid Sub-Mode (either 'rate' or 'frequency')");
                    end
                    
                    % calculate roll damping rate
                    obj.R.SY.roll_damping_rate = ...
                        obj.R.SY.roll_damping_ratio ...
                        * 2 * sqrt( ...
                            (obj.R.SY.roll_rate * 180 / pi) ...
                            * obj.R.CH.I.Ixx) ...
                        * pi / 180;
                    
                    % calculate ride mode parameters
                    obj.R.SY.wheel_spring_rate = ...
                        (obj.R.SY.roll_rate * 180 / pi / 2)...
                        / (obj.R.SY.static_track / 2 * 0.0254)^2;
                    obj.R.SY.wheel_damping_rate = ...
                        (obj.R.SY.roll_damping_rate * 180 / pi / 2)...
                        / (obj.R.SY.static_track / 2 * 0.0254)^2;
                    obj.R.SY.damping_ratio = ...
                        obj.R.SY.wheel_damping_rate ...
                        / (2 * sqrt( ...
                            obj.R.SY.wheel_spring_rate ...
                            * obj.R.CH.I.m / 2));
                    obj.R.SY.omega_n = ...
                        sqrt(...
                            2 * obj.R.SY.wheel_spring_rate ...
                            / obj.R.CH.I.m) ...
                        / (2*pi);
                otherwise
                    % complain
                    error("Error: Invalid Sub-Mode (either 'ride' or 'roll')");
                end
                
                % calculate actual spring and damper rates
                obj.R.SH.spring_rate = ...
                    obj.R.SY.wheel_spring_rate / SY.ride_height_MR^2;
                obj.R.SH.damping_rate = ...
                    obj.R.SY.wheel_damping_rate / SY.ride_height_MR^2;
                
            case 'real' 
                %% for simulating car with purchased components
                % spring and damper rates are set to the actual values
                % of the springs and dampers that could/will be used on
                % the car. wheel and roll spring and damping rates are
                % calculated for the designer's convenience.
                
                if length(varargin) ~= 1
                    error("Real mode doesn''t need more arguments");
                end
                
                % calculate rates at the wheels
                obj.R.SY.wheel_spring_rate = ...
                    obj.R.SH.spring_rate * SY.ride_height_MR^2;
                obj.R.SY.wheel_damping_rate = ...
                    obj.R.SH.damping_rate * SY.ride_height_MR^2;
                
                % calculate rates in roll
                obj.R.SY.roll_rate = ...
                    2 * obj.R.SY.wheel_spring_rate ...
                    * (obj.R.SY.static_track / 2 * 0.0254)^2 ...
                    * pi / 180;
                obj.R.SY.roll_damping_rate = ...
                    2 * obj.R.SY.wheel_damping_rate ...
                    * (obj.R.SY.static_track / 2 * 0.0254)^2 ...
                    * pi / 180;
                
                % calculate damping ratios
                obj.R.SY.damping_ratio = ...
                    obj.R.SY.wheel_damping_rate ...
                    / (2 * sqrt( ...
                        obj.R.SY.wheel_spring_rate ...
                        * obj.R.CH.I.m / 2));
                obj.R.SY.roll_damping_ratio = ...
                    (obj.R.SY.roll_damping_rate * 180 / pi) ...
                    / (2 * sqrt( ...
                        (obj.R.SY.roll_rate * 180 / pi) ...
                        * obj.R.CH.I.Ixx));
                
                % calculate natural frequencies
                obj.R.SY.omega_n = ...
                    sqrt(...
                        2 * obj.R.SY.wheel_spring_rate ...
                        / obj.R.CH.I.m) ...
                    / (2*pi);
                obj.R.SY.roll_omega_n = ...
                    sqrt(...
                        obj.R.SY.roll_rate * (180 / pi) ...
                        / obj.R.CH.I.Ixx) ...
                    / (2*pi);
                
            otherwise 
                %% complain
                % if this section of code is activated, you fucked up.
                error("Error: Invalid Mode (either \'design\ or \'real\')");
                
            end
            
            %% find preload
            SY.static_spring_load = ...
                0.5 * obj.R.CH.I.m * obj.G.gravity / SY.ride_height_MR;
            SY.static_spring_compression = ...
                SY.static_spring_load / obj.R.SH.spring_rate;
            SY.lower_travel = ...
                (obj.R.SH.max_length - obj.R.SH.rest_length);
            obj.R.SH.preload = ...
                SY.static_spring_compression - SY.lower_travel;
            
        end
    end
    
    %% copy function
    methods
        function SP_copy = copy(obj)
            SP_copy = obj;
            SP_copy.G = obj.G.copy;
            SP_copy.F = obj.F.copy;
            SP_copy.R = obj.R.copy;
        end
    end
    
    %% utility functions
    methods (Static)
        function IP = circ_int(C_1, R_1, C_2, R_2, S)
            %% input checking
            sC_1 = size(C_1); sC_2 = size(C_2);
            sR_1 = size(R_1); sR_2 = size(R_2);
            if sC_1(1) ~= 2 || ~isreal(sC_1)
                error('Error: 1st center must be 2x(length) real');
            end
            if sC_2(1) ~= 2 || ~isreal(sC_2)
                error('Error: 2nd center must be 2x(length) real');
            end
            if sR_1(1) ~= 1 || ~isreal(R_1)
                error('Error: 1st radius must be 1x(length) real');
            end
            if sR_2(1) ~= 1 || ~isreal(R_2)
                error('Error: 2nd radius must be 1x(length) real');
            end
            %if max(abs([sC_2(2); sR_1(2); sR_2(2)] - sC_1(2))) > 1e-5
            %    error('Error: all center and radius arguments must have the same horizontal length');
            %end
            if ~(S == -1 || S == 1)
                error('Error: point select must be -1 or 1');
            end
            %% actual calculations
            % find origin (average center of 2 circles)
            center = (C_1 + C_2) / 2;
            % find distance (useful later)
            delta_vector = C_2 - C_1;
            distance = sqrt(delta_vector(1,:).^2 + delta_vector(2,:).^2);
            % set up coordiate system
            % 1st basis points toward second circle
            a_basis = (C_2 - C_1) ./ distance;
            % 2nd basis points left looking along 1st basis
            b_basis = [cosd(-90), -sind(-90); sind(-90), cosd(-90)] ...
                      * a_basis;
            % find parameters defining position of intersections in new
            % coordinate system (note that they are mirror images over the
            % a-axis)
            a = (R_1.^2 - R_2.^2) ./ (2 * distance);
            b = sqrt((R_1.^2 + R_2.^2) ./ 2 - ...
                     (R_1.^2 - R_2.^2).^2 ./ (4 .* distance.^2) - ...
                     distance.^2 ./ 4);
            % convert back to normal coordinate and select which
            % intersection point the user wants (-1 for right side looking
            % towards the second circle, 1 for left)
            IP = center + a .* a_basis + S .* b .* b_basis;
        end
        function RM = RM_gen(angle, axis)
            %% general notes
            % note these are standard mathematical rotation matrices that
            % rotate points around axes using standard RH sign convention.
            % the standard way rotation matrices are used in this model is
            % to represent different coordinate systems/frames of
            % reference. the rotation matrix is used to transform points 
            % in the base frame into the new frame using the equation:
            %
            % (point, new frame) = RM * (point, base frame)
            %
            % if you want to make one of these frames that is simply
            % rotated around an axis using RH sign convention, you actually
            % need to input the negative of the angle you want to rotate
            % by. this is because the rotation matrix rotates points, not
            % frames. imagine a frame that has been rotated around the
            % Z-axis in the positive direction by less than 90deg. the
            % X-axis of the new frame points in the 1st quadrant of the
            % XY-plane of the base frame. a point on the X-axis of the base
            % frame is in the 4th quadrant of the new frame. clearly, to
            % get the position of the point in the new frame from its
            % position in the base frame, it must be rotated around the
            % Z-axis in the negative direction.
            
            %% check input
            if ~isscalar(angle) || ~isreal(angle)
                error("Error: Only 1 (real) angle, please");
            end
            
            %% generate rotation matrix
            switch axis
                case 1 % X rotation
                    RM = [1, 0,           0;            ...
                          0, cosd(angle), -sind(angle); ...
                          0, sind(angle), cosd(angle) ];
                case 2 % Y rotation
                    RM = [cosd(angle),  0, sind(angle); ...
                          0,            1, 0;           ...
                          -sind(angle), 0, cosd(angle)];
                case 3 % Z rotation
                    RM = [cosd(angle), -sind(angle), 0; ...
                          sind(angle), cosd(angle),  0; ...
                          0,           0,            1];
                otherwise % complain
                    error("Error: Invalid Axis");
            end
            
        end
    end
    
end